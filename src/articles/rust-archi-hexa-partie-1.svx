---
title: Apprenons Rust en TDD, et Archi Hexagonale (Partie 1)
description: Ici on est sympa
tags: dev,rust
published: true
publication_date: 2022-10-16T17:57:14+02:00
---

S'il s'agit d'un langage prometteur sur le papier, on peut se demander si Rust est utilisable dans le but de fa√ßonner un logiciel. Comment peut-on s'en servir ? Quels sont les apports de ce langage en termes d'outils permettant la cr√©ation d'un logiciel lisible, propre et test√©? Ce sont les questions qui vous traversent peut-√™tre l‚Äôesprit, et sur lesquelles nous allons nous pencher dans cette s√©rie d'articles.

Dans cet article, nous voulons voir ce que Rust peut apporter lors du d√©veloppement logiciel, et comprendre pourquoi ce langage suscite tant d'int√©r√™t.

Pour le savoir, il faut d'abord pr√©senter de fa√ßon succincte ce qu'est Rust. Pour cela, imaginez ce langage comme un marchand vendant son tapis √† un client. Pour faire simple, Rust est un langage compil√© et cross-platform. Terriblement rapide et √©conome en m√©moire, il rivalise sans probl√®me aucun avec le C et C++. Mieux encore, sa gestion de la m√©moire constitue son point fort : le cycle de vie de cette derni√®re est d√©fini √† la compilation, ce qui signifie qu'il n'y a aucun garbage collector, un avantage rendu possible gr√¢ce √† une architecture du langage adapt√©e, et intelligente.

Si le caract√®re pertinent de ces nouveaux concepts n'est plus √† prouver, ils ont cependant pour d√©faut de complexifier l'apprentissage du langage. Tr√®s abrupte, la courbe d'apprentissage d√©courage ainsi les nouveaux venus. Heureusement, le compilateur est dur, mais bienveillant, dispensant des messages d'erreurs tr√®s utiles.

Pl√©thore d'articles traitent de Rust en d√©tails, le langage √©tant extr√™mement complexe. Cependant, nous n'allons ici que d√©couvrir l'outil, afin de jauger sa capacit√© √† nous aider dans notre projet. Ce dernier ne sera pas un simple Hello World, car, vous en conviendrez : nous sommes plus originaux que √ßa. Nous souhaitons un *service de bienveillance*.

Est il possible d'envisager un d√©veloppement *propre* de ce logiciel ? Regardons ensemble.

## Installation et bases de Rust

Pour installer Rust, vous pouvez suivre les instructions d'installation disponibles sur le site officiel ci-dessous.

[https://doc.rust-lang.org/book/ch01-01-installation.html](https://doc.rust-lang.org/book/ch01-01-installation.html)

Notre nouveau meilleur ami, c'est d√©sormais `rustc` ! Il s'agit du compilateur de rust.

<Callout>
    <span slot="content">Pour toutes les commandes de cet article, nous assumerons que vous serez sur MacOS, ou une distribution Linux. Veuillez adapter vos commandes pour Windows ! (les commandes comme `cd` ou `mkdir`, par exemple.</span>
</Callout>

Pour d√©buter la cr√©ation de notre service de bienveillance, nous allons cr√©er un fichier **main.rs** :

```rust
fn main() {
    println!("Coucou ! N'oublie pas de boire de l'eau.");
}
```

De retour dans votre terminal vous pouvez compiler votre grain de bienveillance :

```bash
$ rustc ./main.rs
$ ./main
Coucou ! N'oublie pas de boire de l'eau.
```

Ceci dit, si rustc est incroyable, nous n'allons pas l'utiliser directement. Nous allons passer par un interm√©diaire qui va grandement nous faciliter la t√¢che : cargo.

### Cr√©ation d'un projet en Rust

Cargo, c'est l'utilitaire de build, ainsi que le gestionnaire de paquets de Rust. Il est tr√®s puissant et va nous permettre de g√©rer des projets complexes.

Nous allons devoir faire des adieux d√©chirants √† notre grain de bienveillance...

```bash
rm ./main.rs
```

...Pour mieux l√©guer la cr√©ation de notre projet Rust √† Cargo, √† l'aide de la commande suivante :

```bash
$ cargo new bienveillance-core --lib
Created library `bienveillance-core` package
$ cd bienveillance-core
```

Un `--lib` a √©t√© sp√©cifi√©, qui ne va pas g√©n√©rer un ex√©cutable mais une librairie. Notre service de bienveillance n'a pas encore pour but d'√™tre ex√©cut√©. Nous n'avons qu'une logique m√©tier. L'ex√©cution est inutile lorsqu'il est possible de tester.

Ainsi nous pouvons voir que des fichiers ont √©t√© cr√©√©s :

```bash
bienveillance-core
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ lib.rs
```

Si nous jetons un oeil au `Cargo.toml` voyons ce qu'il renferme :

```bash
[package]
name = "bienveillance-core"
version = "0.1.0"
authors = ["bachrc <bachrc@dessert.coffee>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
```

Notre nouveau service de bienveillance est d√©sormais initialis√©. `Cargo.toml` va √™tre le fichier renfermant les informations n√©cessaires √† notre build. C‚Äôest le fichier qui sera utilis√© par cargo pour effectuer ses op√©rations.

Voyons voir ce que contient notre lib.rs:

```rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
```

C'est un mod√®le de test par d√©faut, qui s'assure que.... 2 et 2 font 4.

Nous pouvons tout simplement lancer les tests afin de nous en assurer :

```rust
cargo test
```

Le test passe ! Vous pouvez respirer, l'entropie de notre monde est pr√©serv√©e. Vous pouvez enlever le contenu de ce fichier.

<Callout type="INFO">
    <span slot="illu">üíª</span>
    <span slot="content">
        Voir le code de <a href="https://github.com/bachrc/bienveillance-land/tree/a5129fcc14b8953122d6c03b3242376c0e4d0919">cette √©tape</a>
    </span>
</Callout>

### Quelle application d√©sirons-nous ?

Imaginons nos besoins. Par exemple, ‚Äúd√©velopper de la gentillesse √† notre √©gard‚Äù. Recevoir de la chaleur de la part de mon programme sera alors notre besoin. Mais...pour le moment, il devra simplement nous dire bonjour.

Le fichier `lib.rs` est important ici car il va pr√©ciser que notre paquet est une librairie. Mais nous allons enlever les tests dedans, ils n'ont rien √† faire ici.

√Ä c√¥t√© de notre dossier `src`, nous allons cr√©er un dossier `tests`, dans lequel nous allons inscrire notre premier besoin. Quelqu'un pour nous dire bonjour.

## Premi√®re fonctionnalit√© : je veux recevoir un bonjour !

Cr√©ons dans le dossier `tests`, un fichier `welcoming_test.rs` :

`tests/welcoming_test.rs`
```rust
use bienveillance_core::welcomer::Welcomer;

#[test]
fn should_welcome_anyone() {
    let welcome_message: String = Welcomer::compute_welcome_message();

    assert_eq!(welcome_message, "Bonjour !")
}
```

Ceci constitue le premier code que nous √©crivons. D√©composons.

**Premi√®re ligne**<br/>
`use` est le mot cl√© nous permettant d‚Äôimporter des modules ou des structures. Ici, il sert √† importer notre structure `Welcomer`, dans laquelle se trouve la fonction que nous utiliserons. C‚Äôest un m√©canisme qui est rendu ais√© gr√¢ce √† l‚Äôutilisation d‚Äôun IDE tel que IntelliJ o√π Visual Studio Code. A l‚Äôavenir, nous ferons l‚Äôimpasse sur les lignes d‚Äôimport dans l‚Äôarticle, mais vous pourrez toujours les retrouver dans le code qui vous est joint.

**Deuxi√®me ligne**<br/>
Cet attribut sert d'annotation sur la fonction. Quand nous lancerons les tests √† l'aide de Cargo, Cargo reconna√Ætra la fonction, et la consid√®rera comme une fonction de test.

**Troisi√®me ligne**<br/>
Ici, on d√©clare la fonction, avec son nom : `should_welcome_anyone`. Qui explicite ce que nous cherchons √† impl√©menter : n'importe qui doit pouvoir recevoir un bonjour.

**Quatri√®me ligne**<br/>
Celle-ci est plus technique, nous d√©clarons notre premi√®re variable ! Ici nous appelons la fonction `compute_welcome_message` de la classe `Welcomer` qui retourne une variable de type String ! Que nous stockons dans notre variable `welcome_message` √† l'aide de l'op√©rateur `let`.

**Cinqui√®me ligne**<br/>
Nous faisons appel √† la macro `assert_eq!`, que nous utilisons afin de nous assurer que notre variable `welcome_message` vaut bien notre bonjour !

Ce qui nous am√®ne √† la question suivante : qu'est-ce qu'une macro ? Ce n'est pas une fonction ?

Non ! Une macro est en quelque sorte du code qui va g√©n√©rer du code. Elles sont caract√©ris√©es par le point d'exclamation √† la fin de leur nom. Elles sont en g√©n√©ral utilis√©es en tant que sucre syntaxique, afin de rendre le code plus lisible. Chacun peut cr√©er ses propres macros, mais c'est un proc√©d√© complexe pouvant √™tre dangereux pour la maintenabilit√© de votre code ! A utiliser avec parcimonie.

Nous allons maintenant cr√©er notre structure `Welcomer`, car pour le moment, nos tests ne passent pas, mais pas pour la bonne raison : le code ne compile pas !

### Notre premier objet !

Cr√©ons le fichier `src/welcomer.rs` :

```rust
pub struct Welcomer;

impl Welcomer {
    pub fn compute_welcome_message() -> String {
        String::from("")
    }
}
```

Voici donc notre premier objet, notre premier **struct**ure de donn√©es en Rust !

D√©composons l√† encore, ligne par ligne, ce morceau de code.

**Premi√®re ligne**<br/>
Ici nous d√©clarons notre structure de donn√©es. C'est ici que nous pouvons d√©clarer les attributs de notre objet. Pour le moment, il n'en a aucun. C'est pourquoi nous ne d√©clarons que son nom. Nous d√©clarons notre structure en `pub`lique afin de pouvoir y avoir acc√®s en dehors du fichier.

**Deuxi√®me ligne**<br/>
Nous allons ici d√©clarer les comportements de notre structure de donn√©es. S'il est totalement possible d'avoir une `struct` sans avoir d' `impl` √©mentation, l'inverse n'est pas possible, car nous impl√©mentons un comportement √† la structure pr√©c√©demment d√©clar√©e.

**Troisi√®me ligne**<br/>
Nous d√©clarons la fonction `pub`lique `compute_welcome_message` ! Il faut insister sur le fait qu'il s'agisse d'une *fonction* et non d'une *m√©thode* ! La fonction ne d√©pend pas d'une instance de la structure de donn√©es. On peut dire que c'est similaire √† ce qu'est une fonction statique par exemple.

Nous noterons √©galement que notre type de retour est un **String**. Ceci est important pour la suite des √©v√®nements, qui arrivent maintenant.

**Quatri√®me ligne**<br/>
Plusieurs questions doivent vous venir √† l'esprit en voyant cette ligne. Nous allons y r√©pondre ensemble.

<Callout type="QUESTION">
    <span slot="content">La fonction est cens√©e retourner un String, o√π est le `return` ?</span>
</Callout>

En Rust, la derni√®re instruction d'une fonction/m√©thode est ce qui est retourn√© ! Soit ici, l'objet `String` renvoy√© par `String::from("")`

<Callout type="QUESTION">
    <span slot="content">Pourquoi mange-t-on certains animaux, et en domestiquons d'autres ?</span>
</Callout>

Alors je ne vais pas r√©pondre √† cette question

<Callout type="QUESTION">
    <span slot="content">Pourquoi retournons-nous `String::from("")` et non pas "" directement ?</span>
</Callout>

Et c'est l√† que le b√¢t blesse. Disons simplement que notre `""` n'est pas un `String`. Mais un `&str`. Ce qui nous permet de nous pencher sur l'une des fonctionnalit√©s les plus importantes et complexes de Rust : l'Ownership. Il s‚Äôagit d‚Äôun concept complexe que je vous expliquerai d√®s lors que notre test sera passant.

Lorsque nous lan√ßons nos tests, ils sont au rouge.

```
Left:
Right: Bonjour !

thread 'should_welcome_anyone' panicked at 'assertion failed: `(left == right)`
  left: `""`,
 right: `"Bonjour !"`', tests/welcoming_test.rs:7:5
```

Ici notre test attend un bonjour, mais nous n'obtenons qu'une cha√Æne vide. Il faut l'impl√©menter !

`src/welcomer.rs`

```rust
pub struct Welcomer;

impl Welcomer {
    pub fn compute_welcome_message() -> String {
        String::from("Bonjour !")
    }
}
```

Tout √ßa m'a l'air d'√™tre parfait !

Nous avons impl√©ment√© notre premi√®re fonctionnalit√© de `Hello World` ! Et en plus, la fonctionnalit√© est test√©e. Superbe !

<Callout type="INFO">
    <span slot="content">Retrouvez le <a href="https://github.com/bachrc/bienveillance-land/tree/9e80d5a74cb439568dab56bb56b991836e86fa47">code de l'√©tape</a></span>
</Callout>

Prenez une grande inspiration, nous allons rentrer dans le vif du sujet : l‚ÄôOwnership.

### L'Ownership : quel enfer

L'Ownership est une des fonctionnalit√©s centrales du langage, elle est notamment responsable de l'√©tablissement du cycle de vie de la m√©moire de Rust √† la compilation, avec son syst√®me de responsabilit√©s de variables.

C'est un principe complexe que nous ne ferons que survoler ici. Pour plus de d√©tails, cf. le livre de Rust : [Lien vers la r√©f√©rence](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html)

L'Ownership est r√©gi par trois r√®gles :

- Chaque valeur en Rust poss√®de une variable qui est appel√©e sa propri√©taire.
- Il ne peut y avoir qu'un responsable √† la fois
- Quand le responsable sort du scope : la valeur est nettoy√©e de la m√©moire.

Prenons la fonction suivante.

```rust
// Attention : ce code ne COMPILE PAS

fn main() {
    let salutation = String::from("Coucou la petite COMMU");

    let longueur_de_salutation = calculate_length(salutation);

    println!("La chaine {} fait {} caract√®res !", salutation, longueur_de_salutation);
}

fn calculate_length(some_string: String) -> usize {
    some_string.len()
}
```

Cependant, ce code ne compile pas. Pourquoi donc ?

**Ligne 4**<br/>
La variable `salutation` a la propri√©t√© de sa valeur.

**Ligne 6**<br/>
Est ici d√©l√©gu√©e la propri√©t√© du contenu de la valeur jusqu'ici poss√©d√©e par `salutation` √† la fonction `calculate_length`. **La fonction calculate_length est d√©sormais propri√©taire de la valeur de contenu.**

**Ligne 12**<br/>
La fonction retourne la longueur de la cha√Æne de caract√®res dont elle a la propri√©t√©. **Cependant**, elle ne fait rien de la valeur de cette cha√Æne. **La valeur de celle-ci est donc nettoy√©e.**

**Ligne 8**<br/>
L'erreur se situe ici. La propri√©t√© de la variable ayant √©t√© d√©l√©gu√©e √† `calculate_length`, la variable `salutation` ne poss√®de plus rien ! On ne peut plus l'afficher, ni m√™me l'utiliser. Son contenu a √©t√© nettoy√© √† la sortie du scope de `calculate_length`.

Quand nous compilons le code, cette erreur nous est indiqu√©e de mani√®re tr√®s explicite :

```
error[E0382]: borrow of moved value: `salutation`
 --> src/main.rs:8:51
  |
4 |     let salutation = String::from("Coucou la petite COMMU");
  |         ---------- move occurs because `salutation` has type `String`, which does not implement the `Copy` trait
5 |
6 |     let longueur_de_salutation = calculate_length(salutation);
  |                                                   ---------- value moved here
7 |
8 |     println!("La chaine {} fait {} caract√®res !", salutation, longueur_de_salutation);
  |                                                   ^^^^^^^^^^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `playground`
```

Comme nous l'avons sp√©cifi√© auparavant : le compilateur nous fait certes un peu mal, mais avec p√©dagogie : en nous aidant par l'explication √† ne plus r√©p√©ter l'erreur, il nous permet de progresser. `rustc`, c'est plus qu'un compilateur. *C'est un ami.*

<Callout type="QUESTION">
    <span slot="content">Quoi ? √áa veut dire qu'√† chaque fois que je veux mettre une variable en param√®tre d'une fonction, je ne peux plus l'utiliser derri√®re ?! Il est tout p√©t√© ton langage l√† !</span>
</Callout>

Fort heureusement, dans le monde actuel, lorsqu'il n'est pas possible d'acqu√©rir un bien, nous avons la CHANCE de pouvoir faire un emprunt ! Et c'est pareil en Rust, avec la m√©canique du Borrowing, de l'emprunt.

### Emprunter des valeurs

En Rust, il est possible d'expliciter que nous ne souhaitons pas avoir la propri√©t√© d'une variable, mais seulement une r√©f√©rence √† sa valeur. Modifions notre code afin d'utiliser la m√©canique de l'emprunt.

```rust
// Attention : ce code COMPILE

fn main() {
    let salutation = String::from("Coucou la petite COMMU");

    let longueur_de_salutation = calculate_length(&salutation);

    println!("La chaine {} fait {} caract√®res !", salutation, longueur_de_salutation);
}

fn calculate_length(some_string: &String) -> usize {
    some_string.len()
}
```

Vous pouvez noter deux diff√©rences ici, avec l'introduction du caract√®re de r√©f√©rence `&` :

**Ligne 6**<br/>
Nous ne donnons plus la propri√©t√© de la valeur de `salutation` √† `calculate_length` : nous donnons une **r√©f√©rence** √† la valeur de `salutation`. Notre variable `salutation` garde ainsi la propri√©t√© de sa valeur.

**Ligne 11**<br/>
La fonction `calculate_length` indique qu'elle ne requiert plus la propri√©t√© de la valeur : elle n'indique n'avoir besoin que d'une r√©f√©rence √† cette valeur. A la fin du scope de la fonction, nous ne ferons que mettre fin √† l'emprunt, et notre programme va ainsi pouvoir compiler. V√©rifions !

```
La chaine Coucou la petite COMMU fait 22 caract√®res !
```

Notre programme avec l'emprunt fonctionne d√©sormais !

<Callout type="QUESTION">
    <span slot="illu">
        ‚ùî
    </span>
    <span slot="content">
        Ok... mais pourquoi on parle de tout √ßa en fait ? On parlait pas de cha√Æne de caract√®res ?
    </span>
</Callout>

Oui ! Revenons au point de base. Pourquoi y a-t-il `&str` et `String` ?

Tr√®s simplement : `&str` est une r√©f√©rence √† une partie d'une `String`. Lorsque vous compilez votre code avec des cha√Ænes de caract√®res, vos cha√Ænes de caract√®res se situent dans une m√©moire allou√©e √† des valeurs en lecture seule. Lorsque votre programme tourne : *votre variable est donc une r√©f√©rence √† ce texte allou√© dans cette m√©moire en lecture seule.* Tout simplement parce que votre variable n'en a pas la propri√©t√© : c‚Äôest cette m√©moire en lecture seule qui en a la propri√©t√©. Vous ne faites qu'un emprunt.

Revenons √† notre code.

```rust
pub struct Welcomer;

impl Welcomer {
    pub fn compute_welcome_message() -> String {
        String::from("")
    }
}
```

Pourquoi donc nous pr√©f√©rons retourner un `String` plut√¥t qu'un `&str` ? Pour pouvoir donner la propri√©t√© de la cha√Æne de caract√®res √† l'appelant de la fonction, afin de nous permettre une plus grande souplesse lors de l'utilisation.

Voil√†, en r√©sum√©, l'explication de l'ownership, qui peut sembler complexe de prime abord mais ne s'av√®re √™tre qu'une gymnastique mentale, qui, ne vous inqui√©tez pas, devient naturelle au fil du temps.

Dans le prochain article, nous allons continuer nos cycles de d√©veloppement, afin d'obtenir toujours plus de chaleur. Comme avec des accueils personnalis√©s, accord√©s √† nos pronoms, ainsi que des compliments ! Que demander de plus ?

<script>
    import Callout from "../components/articles/Callout.svelte";
</script>
